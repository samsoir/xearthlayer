//! Ortho4XP scenery processor.
//!
//! Processes output from Ortho4XP into XEarthLayer packages. Ortho4XP is a popular
//! tool for generating orthophoto scenery for X-Plane from satellite imagery.

use std::collections::HashSet;
use std::fs;
use std::path::Path;

use super::{ProcessSummary, SceneryFormat, SceneryProcessor, SceneryScanResult, TileInfo};
use crate::package::PackageType;
use crate::publisher::{PublishError, PublishResult, Repository};

/// Ortho4XP output processor.
///
/// Scans and validates Ortho4XP tile directories, organizing them into
/// XEarthLayer package format.
///
/// # Ortho4XP Output Structure
///
/// Ortho4XP produces tiles in the following structure:
///
/// ```text
/// Tiles/
/// ├── +37-118/
/// │   ├── Earth nav data/
/// │   │   └── +37-118.dsf
/// │   ├── terrain/
/// │   │   ├── 25264_10912_BI16.ter
/// │   │   └── ...
/// │   └── textures/
/// │       ├── 25264_10912_BI16.dds      # Skipped
/// │       ├── 25264_10912_BI16_sea.png  # Kept
/// │       └── ...
/// └── +37-119/
///     └── ...
/// ```
///
/// # File Handling
///
/// - **DSF files**: Kept (terrain mesh data)
/// - **TER files**: Kept (terrain definitions)
/// - **Mask files** (`*_sea.png`, `*_mask.png`): Kept (water boundaries)
/// - **DDS files**: Skipped by default (XEarthLayer generates these on-demand)
#[derive(Debug, Clone)]
pub struct Ortho4XPProcessor {
    /// Skip DDS files (they will be regenerated by XEarthLayer).
    skip_dds: bool,
}

impl Default for Ortho4XPProcessor {
    fn default() -> Self {
        Self::new()
    }
}

impl Ortho4XPProcessor {
    /// Create a new processor with default settings.
    ///
    /// By default, DDS files are skipped because XEarthLayer generates them on-demand.
    pub fn new() -> Self {
        Self { skip_dds: true }
    }

    /// Set whether to skip DDS files.
    ///
    /// By default, DDS files are skipped because XEarthLayer generates them on-demand.
    /// Set to `false` to include DDS files in the package (for standalone distribution).
    pub fn with_skip_dds(mut self, skip: bool) -> Self {
        self.skip_dds = skip;
        self
    }

    /// Scan a single tile directory.
    ///
    /// Returns `None` if the directory doesn't look like an Ortho4XP tile.
    fn scan_tile_directory(&self, path: &Path) -> PublishResult<Option<TileInfo>> {
        let dir_name = match path.file_name().and_then(|n| n.to_str()) {
            Some(name) => name,
            None => return Ok(None),
        };

        // Try to parse the tile ID (format: +/-NN+/-NNN)
        let (latitude, longitude) = match Self::parse_tile_id(dir_name) {
            Some(coords) => coords,
            None => return Ok(None),
        };

        let mut tile = TileInfo::new(dir_name, path, latitude, longitude);

        // Scan subdirectories
        self.scan_earth_nav_data(path, &mut tile.dsf_files)?;
        self.scan_terrain(path, &mut tile.ter_files)?;
        self.scan_textures(path, &mut tile.mask_files, &mut tile.dds_files)?;

        // A valid tile must have at least one DSF file
        if tile.dsf_files.is_empty() {
            return Ok(None);
        }

        Ok(Some(tile))
    }

    /// Ortho4XP tile directory prefix.
    const TILE_PREFIX: &'static str = "zOrtho4XP_";

    /// Parse a tile ID into latitude and longitude.
    ///
    /// Expected formats:
    /// - `zOrtho4XP_+37-118` (Ortho4XP output format)
    /// - `+37-118` or `-12+045` (bare coordinate format)
    fn parse_tile_id(id: &str) -> Option<(i32, i32)> {
        // Strip the zOrtho4XP_ prefix if present
        let coords = id.strip_prefix(Self::TILE_PREFIX).unwrap_or(id);

        if coords.len() < 7 {
            return None;
        }

        // Find where longitude starts (second + or -)
        let mut sign_positions = Vec::new();
        for (i, c) in coords.chars().enumerate() {
            if c == '+' || c == '-' {
                sign_positions.push(i);
            }
        }

        if sign_positions.len() < 2 {
            return None;
        }

        let lat_str = &coords[..sign_positions[1]];
        let lon_str = &coords[sign_positions[1]..];

        let latitude: i32 = lat_str.parse().ok()?;
        let longitude: i32 = lon_str.parse().ok()?;

        // Validate ranges
        if !(-90..=90).contains(&latitude) || !(-180..=180).contains(&longitude) {
            return None;
        }

        Some((latitude, longitude))
    }

    /// Scan Earth nav data directory for DSF files.
    ///
    /// Ortho4XP places DSF files in grid subdirectories like:
    /// `Earth nav data/+30-120/+37-118.dsf`
    fn scan_earth_nav_data(
        &self,
        tile_path: &Path,
        dsf_files: &mut Vec<std::path::PathBuf>,
    ) -> PublishResult<()> {
        let earth_nav = tile_path.join("Earth nav data");
        if !earth_nav.exists() {
            return Ok(());
        }

        // Scan grid subdirectories for DSF files
        let entries = fs::read_dir(&earth_nav).map_err(|e| PublishError::ReadFailed {
            path: earth_nav.clone(),
            source: e,
        })?;

        for entry in entries {
            let entry = entry.map_err(|e| PublishError::ReadFailed {
                path: earth_nav.clone(),
                source: e,
            })?;

            let path = entry.path();
            if path.is_dir() {
                // Scan this grid subdirectory for DSF files
                self.collect_files_by_extension(&path, "dsf", dsf_files)?;
            }
        }

        Ok(())
    }

    /// Scan terrain directory for .ter files.
    fn scan_terrain(
        &self,
        tile_path: &Path,
        ter_files: &mut Vec<std::path::PathBuf>,
    ) -> PublishResult<()> {
        let terrain = tile_path.join("terrain");
        if !terrain.exists() {
            return Ok(());
        }

        self.collect_files_by_extension(&terrain, "ter", ter_files)?;
        Ok(())
    }

    /// Scan textures directory for mask files and DDS files.
    ///
    /// In Ortho4XP output, mask files are PNG images (water boundaries) with
    /// naming like `25296_11280_ZL16.png`. DDS files are orthophoto textures
    /// which are typically skipped since XEarthLayer generates them on-demand.
    fn scan_textures(
        &self,
        tile_path: &Path,
        mask_files: &mut Vec<std::path::PathBuf>,
        dds_files: &mut Vec<std::path::PathBuf>,
    ) -> PublishResult<()> {
        let textures = tile_path.join("textures");
        if !textures.exists() {
            return Ok(());
        }

        let entries = fs::read_dir(&textures).map_err(|e| PublishError::ReadFailed {
            path: textures.clone(),
            source: e,
        })?;

        for entry in entries {
            let entry = entry.map_err(|e| PublishError::ReadFailed {
                path: textures.clone(),
                source: e,
            })?;

            let path = entry.path();
            if !path.is_file() {
                continue;
            }

            let filename = match path.file_name().and_then(|n| n.to_str()) {
                Some(name) => name.to_lowercase(),
                None => continue,
            };

            // PNG files are water mask images (e.g., 25296_11280_ZL16.png)
            if filename.ends_with(".png") {
                mask_files.push(path);
            } else if filename.ends_with(".dds") {
                dds_files.push(path);
            }
        }

        Ok(())
    }

    /// Collect files with a specific extension from a directory.
    fn collect_files_by_extension(
        &self,
        dir: &Path,
        extension: &str,
        files: &mut Vec<std::path::PathBuf>,
    ) -> PublishResult<()> {
        let entries = fs::read_dir(dir).map_err(|e| PublishError::ReadFailed {
            path: dir.to_path_buf(),
            source: e,
        })?;

        for entry in entries {
            let entry = entry.map_err(|e| PublishError::ReadFailed {
                path: dir.to_path_buf(),
                source: e,
            })?;

            let path = entry.path();
            if path.is_file() {
                if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
                    if ext.eq_ignore_ascii_case(extension) {
                        files.push(path);
                    }
                }
            }
        }

        Ok(())
    }

    /// Get the 10-degree grid subdirectory for DSF files.
    ///
    /// X-Plane organizes DSF files in 10° latitude × 10° longitude grid directories.
    /// E.g., latitude 37, longitude -118 goes in `+30-120/`.
    fn dsf_grid_dir(
        &self,
        earth_nav_dir: &Path,
        lat: i32,
        lon: i32,
    ) -> PublishResult<std::path::PathBuf> {
        // Round down to nearest 10 degrees for both lat and lon
        let grid_lat = (lat.div_euclid(10)) * 10;
        let grid_lon = (lon.div_euclid(10)) * 10;

        let dir_name = format!("{:+03}{:+04}", grid_lat, grid_lon);

        let dir_path = earth_nav_dir.join(&dir_name);
        fs::create_dir_all(&dir_path).map_err(|e| PublishError::CreateDirectoryFailed {
            path: dir_path.clone(),
            source: e,
        })?;

        Ok(dir_path)
    }
}

impl SceneryProcessor for Ortho4XPProcessor {
    fn name(&self) -> &str {
        "Ortho4XP"
    }

    fn scenery_format(&self) -> SceneryFormat {
        SceneryFormat::XPlane12
    }

    fn scan(&self, source: &Path) -> PublishResult<SceneryScanResult> {
        if !source.exists() {
            return Err(PublishError::InvalidSource(format!(
                "source path does not exist: {}",
                source.display()
            )));
        }

        if !source.is_dir() {
            return Err(PublishError::InvalidSource(format!(
                "source path is not a directory: {}",
                source.display()
            )));
        }

        let mut tiles = Vec::new();

        let entries = fs::read_dir(source).map_err(|e| PublishError::ReadFailed {
            path: source.to_path_buf(),
            source: e,
        })?;

        for entry in entries {
            let entry = entry.map_err(|e| PublishError::ReadFailed {
                path: source.to_path_buf(),
                source: e,
            })?;

            let path = entry.path();
            if !path.is_dir() {
                continue;
            }

            if let Some(tile_info) = self.scan_tile_directory(&path)? {
                tiles.push(tile_info);
            }
        }

        if tiles.is_empty() {
            return Err(PublishError::NoTilesFound(source.to_path_buf()));
        }

        // Sort tiles by latitude, then longitude for consistent ordering
        tiles.sort_by_key(|t| (t.latitude, t.longitude));

        Ok(SceneryScanResult::new(tiles))
    }

    fn process(
        &self,
        scan_result: &SceneryScanResult,
        region: &str,
        package_type: PackageType,
        repo: &Repository,
    ) -> PublishResult<ProcessSummary> {
        let package_dir = repo.package_dir(region, package_type);

        // Create package directory structure
        fs::create_dir_all(&package_dir).map_err(|e| PublishError::CreateDirectoryFailed {
            path: package_dir.clone(),
            source: e,
        })?;

        let earth_nav_dir = package_dir.join("Earth nav data");
        let terrain_dir = package_dir.join("terrain");
        let textures_dir = package_dir.join("textures");

        for dir in [&earth_nav_dir, &terrain_dir, &textures_dir] {
            fs::create_dir_all(dir).map_err(|e| PublishError::CreateDirectoryFailed {
                path: dir.clone(),
                source: e,
            })?;
        }

        let mut summary = ProcessSummary::new();

        // Track files we've already copied to avoid duplicates
        let mut copied_ter: HashSet<String> = HashSet::new();
        let mut copied_masks: HashSet<String> = HashSet::new();

        for tile in &scan_result.tiles {
            summary.tile_count += 1;

            // Copy DSF files into a subdirectory based on 10-degree grid
            let dsf_subdir = self.dsf_grid_dir(&earth_nav_dir, tile.latitude, tile.longitude)?;
            for dsf_file in &tile.dsf_files {
                if let Some(filename) = dsf_file.file_name() {
                    let dest = dsf_subdir.join(filename);
                    fs::copy(dsf_file, &dest).map_err(|e| PublishError::WriteFailed {
                        path: dest,
                        source: e,
                    })?;
                    summary.dsf_count += 1;
                }
            }

            // Copy terrain files (deduplicate by filename)
            for ter_file in &tile.ter_files {
                if let Some(filename) = ter_file.file_name().and_then(|n| n.to_str()) {
                    if copied_ter.insert(filename.to_string()) {
                        let dest = terrain_dir.join(filename);
                        fs::copy(ter_file, &dest).map_err(|e| PublishError::WriteFailed {
                            path: dest,
                            source: e,
                        })?;
                        summary.ter_count += 1;
                    }
                }
            }

            // Copy mask files (deduplicate by filename)
            for mask_file in &tile.mask_files {
                if let Some(filename) = mask_file.file_name().and_then(|n| n.to_str()) {
                    if copied_masks.insert(filename.to_string()) {
                        let dest = textures_dir.join(filename);
                        fs::copy(mask_file, &dest).map_err(|e| PublishError::WriteFailed {
                            path: dest,
                            source: e,
                        })?;
                        summary.mask_count += 1;
                    }
                }
            }

            // Count skipped DDS files
            if self.skip_dds {
                summary.dds_skipped += tile.dds_files.len();
            }
        }

        Ok(summary)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use proptest::prelude::*;
    use tempfile::TempDir;

    /// Create a mock Ortho4XP tile directory matching real Ortho4XP output structure.
    ///
    /// Real structure: zOrtho4XP_+37-118/
    ///   ├── Earth nav data/+30-120/+37-118.dsf   (DSF in 10° grid subdir)
    ///   ├── terrain/*.ter
    ///   └── textures/*.png (water masks)
    fn create_mock_tile(temp: &Path, coords: &str) {
        let tile_dir = temp.join(format!("zOrtho4XP_{}", coords));

        // Parse coordinates for DSF grid calculation
        let (lat, lon) = Ortho4XPProcessor::parse_tile_id(coords).unwrap();
        let grid_lat = (lat.div_euclid(10)) * 10;
        let grid_lon = (lon.div_euclid(10)) * 10;
        let grid_dir = format!("{:+03}{:+04}", grid_lat, grid_lon);

        // Earth nav data with DSF in proper grid subdirectory
        let earth_nav = tile_dir.join("Earth nav data").join(&grid_dir);
        fs::create_dir_all(&earth_nav).unwrap();
        fs::write(earth_nav.join(format!("{}.dsf", coords)), b"mock dsf").unwrap();

        // Terrain files
        let terrain = tile_dir.join("terrain");
        fs::create_dir_all(&terrain).unwrap();
        fs::write(terrain.join("25264_10912_BI16.ter"), b"mock ter").unwrap();
        fs::write(terrain.join("25264_10913_BI16.ter"), b"mock ter 2").unwrap();

        // Textures with PNG masks and DDS (matching real Ortho4XP naming)
        let textures = tile_dir.join("textures");
        fs::create_dir_all(&textures).unwrap();
        fs::write(textures.join("25264_10912_ZL16.png"), b"mock mask").unwrap();
        fs::write(textures.join("25264_10912_BI16.dds"), b"mock dds").unwrap();
    }

    #[test]
    fn test_processor_new() {
        let processor = Ortho4XPProcessor::new();
        assert!(processor.skip_dds);
    }

    #[test]
    fn test_processor_default() {
        let processor = Ortho4XPProcessor::default();
        assert!(processor.skip_dds);
    }

    #[test]
    fn test_processor_with_skip_dds() {
        let processor = Ortho4XPProcessor::new().with_skip_dds(false);
        assert!(!processor.skip_dds);
    }

    #[test]
    fn test_processor_name() {
        let processor = Ortho4XPProcessor::new();
        assert_eq!(processor.name(), "Ortho4XP");
    }

    #[test]
    fn test_processor_scenery_format() {
        let processor = Ortho4XPProcessor::new();
        assert_eq!(processor.scenery_format(), SceneryFormat::XPlane12);
    }

    #[test]
    fn test_parse_tile_id_valid() {
        // Bare coordinate format
        assert_eq!(
            Ortho4XPProcessor::parse_tile_id("+37-118"),
            Some((37, -118))
        );
        assert_eq!(Ortho4XPProcessor::parse_tile_id("-12+045"), Some((-12, 45)));
        assert_eq!(Ortho4XPProcessor::parse_tile_id("+00+000"), Some((0, 0)));
        assert_eq!(
            Ortho4XPProcessor::parse_tile_id("-90-180"),
            Some((-90, -180))
        );
        assert_eq!(Ortho4XPProcessor::parse_tile_id("+90+180"), Some((90, 180)));
    }

    #[test]
    fn test_parse_tile_id_with_prefix() {
        // Ortho4XP directory format with zOrtho4XP_ prefix
        assert_eq!(
            Ortho4XPProcessor::parse_tile_id("zOrtho4XP_+37-118"),
            Some((37, -118))
        );
        assert_eq!(
            Ortho4XPProcessor::parse_tile_id("zOrtho4XP_-12+045"),
            Some((-12, 45))
        );
        assert_eq!(
            Ortho4XPProcessor::parse_tile_id("zOrtho4XP_+00+000"),
            Some((0, 0))
        );
    }

    #[test]
    fn test_parse_tile_id_invalid() {
        assert_eq!(Ortho4XPProcessor::parse_tile_id("invalid"), None);
        assert_eq!(Ortho4XPProcessor::parse_tile_id("+37"), None);
        assert_eq!(Ortho4XPProcessor::parse_tile_id("+91-118"), None); // lat out of range
        assert_eq!(Ortho4XPProcessor::parse_tile_id("+37-181"), None); // lon out of range
        assert_eq!(Ortho4XPProcessor::parse_tile_id("zOrtho4XP_invalid"), None);
    }

    #[test]
    fn test_scan_nonexistent_source() {
        let processor = Ortho4XPProcessor::new();
        let result = processor.scan(Path::new("/nonexistent/path"));
        assert!(matches!(result, Err(PublishError::InvalidSource(_))));
    }

    #[test]
    fn test_scan_empty_directory() {
        let temp = TempDir::new().unwrap();
        let processor = Ortho4XPProcessor::new();
        let result = processor.scan(temp.path());
        assert!(matches!(result, Err(PublishError::NoTilesFound(_))));
    }

    #[test]
    fn test_scan_valid_tiles() {
        let temp = TempDir::new().unwrap();
        create_mock_tile(temp.path(), "+37-118");
        create_mock_tile(temp.path(), "+37-119");

        let processor = Ortho4XPProcessor::new();
        let result = processor.scan(temp.path()).unwrap();

        assert_eq!(result.tiles.len(), 2);
        // Sorted by (lat, lon): -119 < -118, so +37-119 comes first
        // The tile ID includes the zOrtho4XP_ prefix as that's the directory name
        assert_eq!(result.tiles[0].id, "zOrtho4XP_+37-119");
        assert_eq!(result.tiles[0].latitude, 37);
        assert_eq!(result.tiles[0].longitude, -119);
        assert_eq!(result.tiles[0].dsf_files.len(), 1);
        assert_eq!(result.tiles[0].ter_files.len(), 2);
        assert_eq!(result.tiles[0].mask_files.len(), 1);
        assert_eq!(result.tiles[0].dds_files.len(), 1);
    }

    #[test]
    fn test_scan_sorted_by_coordinates() {
        let temp = TempDir::new().unwrap();
        create_mock_tile(temp.path(), "+38-117");
        create_mock_tile(temp.path(), "+37-118");
        create_mock_tile(temp.path(), "+37-117");

        let processor = Ortho4XPProcessor::new();
        let result = processor.scan(temp.path()).unwrap();

        // Sorted by (lat, lon): same lat sorts by lon, -118 < -117
        assert_eq!(result.tiles[0].id, "zOrtho4XP_+37-118");
        assert_eq!(result.tiles[1].id, "zOrtho4XP_+37-117");
        assert_eq!(result.tiles[2].id, "zOrtho4XP_+38-117");
    }

    #[test]
    fn test_process_creates_package_structure() {
        let source_temp = TempDir::new().unwrap();
        create_mock_tile(source_temp.path(), "+37-118");

        let repo_temp = TempDir::new().unwrap();
        let repo = Repository::init(repo_temp.path()).unwrap();

        let processor = Ortho4XPProcessor::new();
        let scan_result = processor.scan(source_temp.path()).unwrap();
        let summary = processor
            .process(&scan_result, "na", PackageType::Ortho, &repo)
            .unwrap();

        assert_eq!(summary.tile_count, 1);
        assert_eq!(summary.dsf_count, 1);
        assert_eq!(summary.ter_count, 2);
        assert_eq!(summary.mask_count, 1);
        assert_eq!(summary.dds_skipped, 1);

        // Check package structure
        let pkg_dir = repo.package_dir("na", PackageType::Ortho);
        assert!(pkg_dir.join("Earth nav data").exists());
        assert!(pkg_dir.join("terrain").exists());
        assert!(pkg_dir.join("textures").exists());
    }

    #[test]
    fn test_process_dsf_grid_organization() {
        let source_temp = TempDir::new().unwrap();
        create_mock_tile(source_temp.path(), "+37-118");

        let repo_temp = TempDir::new().unwrap();
        let repo = Repository::init(repo_temp.path()).unwrap();

        let processor = Ortho4XPProcessor::new();
        let scan_result = processor.scan(source_temp.path()).unwrap();
        processor
            .process(&scan_result, "na", PackageType::Ortho, &repo)
            .unwrap();

        // DSF should be in +30-120 grid directory (10° lat × 10° lon grouping)
        let pkg_dir = repo.package_dir("na", PackageType::Ortho);
        let dsf_path = pkg_dir.join("Earth nav data/+30-120/+37-118.dsf");
        assert!(dsf_path.exists(), "DSF file should be in grid directory");
    }

    #[test]
    fn test_process_deduplicates_ter_files() {
        let source_temp = TempDir::new().unwrap();

        // Create two tiles - both have the same .ter filenames from create_mock_tile
        // (25264_10912_BI16.ter and 25264_10913_BI16.ter)
        create_mock_tile(source_temp.path(), "+37-118");
        create_mock_tile(source_temp.path(), "+37-119");

        // Add a shared terrain file name to both (using zOrtho4XP_ prefix)
        let ter1 = source_temp
            .path()
            .join("zOrtho4XP_+37-118/terrain/shared.ter");
        let ter2 = source_temp
            .path()
            .join("zOrtho4XP_+37-119/terrain/shared.ter");
        fs::write(&ter1, b"shared content").unwrap();
        fs::write(&ter2, b"shared content").unwrap();

        let repo_temp = TempDir::new().unwrap();
        let repo = Repository::init(repo_temp.path()).unwrap();

        let processor = Ortho4XPProcessor::new();
        let scan_result = processor.scan(source_temp.path()).unwrap();
        let summary = processor
            .process(&scan_result, "na", PackageType::Ortho, &repo)
            .unwrap();

        // Both tiles have the same 3 .ter filenames, so after deduplication: 3 unique files
        // - 25264_10912_BI16.ter (shared by both tiles)
        // - 25264_10913_BI16.ter (shared by both tiles)
        // - shared.ter (added to both tiles)
        assert_eq!(summary.ter_count, 3);
    }

    #[test]
    fn test_dsf_grid_calculation() {
        let temp = TempDir::new().unwrap();
        let processor = Ortho4XPProcessor::new();

        // Test various coordinates
        // Grid uses 10° latitude × 10° longitude (both rounded down to nearest 10)
        let cases = vec![
            (37, -118, "+30-120"),  // lat 37 rounds to 30, lon -118 rounds to -120
            (0, 0, "+00+000"),      // lat 0, lon 0
            (-5, -5, "-10-010"),    // lat -5 rounds to -10, lon -5 rounds to -10
            (45, 10, "+40+010"),    // lat 45 rounds to 40, lon 10 rounds to 10
            (-45, -170, "-50-170"), // lat -45 rounds to -50, lon -170 rounds to -170
            (37, -127, "+30-130"),  // lat 37 rounds to 30, lon -127 rounds to -130
            (41, -125, "+40-130"),  // Example from real Ortho4XP data
        ];

        for (lat, lon, expected_dir) in cases {
            let result = processor.dsf_grid_dir(temp.path(), lat, lon).unwrap();
            assert!(
                result.ends_with(expected_dir),
                "lat={}, lon={} should give {}, got {:?}",
                lat,
                lon,
                expected_dir,
                result
            );
        }
    }

    #[test]
    fn test_processor_is_send_sync() {
        fn assert_send_sync<T: Send + Sync>() {}
        assert_send_sync::<Ortho4XPProcessor>();
    }

    #[test]
    fn test_processor_as_trait_object() {
        let processor: Box<dyn SceneryProcessor> = Box::new(Ortho4XPProcessor::new());
        assert_eq!(processor.name(), "Ortho4XP");
        assert_eq!(processor.scenery_format(), SceneryFormat::XPlane12);
    }

    #[test]
    fn test_processor_clone() {
        let processor = Ortho4XPProcessor::new().with_skip_dds(false);
        let cloned = processor.clone();
        assert_eq!(processor.skip_dds, cloned.skip_dds);
    }

    #[test]
    fn test_processor_debug() {
        let processor = Ortho4XPProcessor::new();
        let debug = format!("{:?}", processor);
        assert!(debug.contains("Ortho4XPProcessor"));
    }

    // Property-based tests for DSF grid calculation
    mod property_tests {
        use super::*;

        proptest! {
            /// Grid latitude is always a multiple of 10 and within valid range
            #[test]
            fn grid_lat_is_multiple_of_10(lat in -90i32..=90i32) {
                let grid_lat = (lat.div_euclid(10)) * 10;
                prop_assert_eq!(grid_lat % 10, 0, "Grid lat {} should be multiple of 10", grid_lat);
                prop_assert!((-90..=90).contains(&grid_lat), "Grid lat {} out of range", grid_lat);
            }

            /// Grid longitude is always a multiple of 10 and within valid range
            #[test]
            fn grid_lon_is_multiple_of_10(lon in -180i32..=180i32) {
                let grid_lon = (lon.div_euclid(10)) * 10;
                prop_assert_eq!(grid_lon % 10, 0, "Grid lon {} should be multiple of 10", grid_lon);
                prop_assert!((-180..=180).contains(&grid_lon), "Grid lon {} out of range", grid_lon);
            }

            /// Original coordinate always falls within its grid cell
            #[test]
            fn coord_within_grid_cell(lat in -90i32..=90i32, lon in -180i32..=180i32) {
                let grid_lat = (lat.div_euclid(10)) * 10;
                let grid_lon = (lon.div_euclid(10)) * 10;

                // Coordinate should be >= grid start and < grid start + 10
                prop_assert!(lat >= grid_lat, "lat {} should be >= grid_lat {}", lat, grid_lat);
                prop_assert!(lat < grid_lat + 10, "lat {} should be < grid_lat + 10 = {}", lat, grid_lat + 10);
                prop_assert!(lon >= grid_lon, "lon {} should be >= grid_lon {}", lon, grid_lon);
                prop_assert!(lon < grid_lon + 10, "lon {} should be < grid_lon + 10 = {}", lon, grid_lon + 10);
            }

            /// Grid directory name format is correct
            #[test]
            fn grid_dir_name_format(lat in -90i32..=90i32, lon in -180i32..=180i32) {
                let temp = TempDir::new().unwrap();
                let processor = Ortho4XPProcessor::new();
                let result = processor.dsf_grid_dir(temp.path(), lat, lon).unwrap();

                let dir_name = result.file_name().unwrap().to_str().unwrap();

                // Should be 7 characters: sign + 2 digits + sign + 3 digits
                prop_assert_eq!(dir_name.len(), 7, "Dir name {} should be 7 chars", dir_name);

                // Should start with + or -
                let first_char = dir_name.chars().next().unwrap();
                prop_assert!(first_char == '+' || first_char == '-',
                    "Dir name {} should start with + or -", dir_name);

                // Should have sign at position 3 (for longitude)
                let fourth_char = dir_name.chars().nth(3).unwrap();
                prop_assert!(fourth_char == '+' || fourth_char == '-',
                    "Dir name {} should have sign at position 3", dir_name);
            }

            /// Adjacent coordinates in same grid produce same directory
            #[test]
            fn adjacent_coords_same_grid(
                base_lat in -80i32..=80i32,
                base_lon in -170i32..=170i32,
                offset_lat in 0i32..10i32,
                offset_lon in 0i32..10i32
            ) {
                let temp = TempDir::new().unwrap();
                let processor = Ortho4XPProcessor::new();

                // Calculate the grid base
                let grid_lat = (base_lat.div_euclid(10)) * 10;
                let grid_lon = (base_lon.div_euclid(10)) * 10;

                // Two coordinates within the same grid cell
                let lat1 = grid_lat + (offset_lat % 10);
                let lon1 = grid_lon + (offset_lon % 10);
                let lat2 = grid_lat + ((offset_lat + 1) % 10);
                let lon2 = grid_lon + ((offset_lon + 1) % 10);

                let dir1 = processor.dsf_grid_dir(temp.path(), lat1, lon1).unwrap();
                let dir2 = processor.dsf_grid_dir(temp.path(), lat2, lon2).unwrap();

                prop_assert_eq!(dir1, dir2,
                    "Coords ({}, {}) and ({}, {}) should produce same grid dir",
                    lat1, lon1, lat2, lon2);
            }

            /// Coordinates in different grid cells produce different directories
            #[test]
            fn different_grids_different_dirs(
                lat1 in -80i32..=80i32,
                lon1 in -170i32..=170i32
            ) {
                let temp = TempDir::new().unwrap();
                let processor = Ortho4XPProcessor::new();

                // Coordinate in next grid cell (add 10)
                let lat2 = lat1 + 10;
                let lon2 = lon1 + 10;

                // Skip if second coordinate would be out of range
                if lat2 <= 90 && lon2 <= 180 {
                    let dir1 = processor.dsf_grid_dir(temp.path(), lat1, lon1).unwrap();
                    let dir2 = processor.dsf_grid_dir(temp.path(), lat2, lon2).unwrap();

                    prop_assert_ne!(dir1, dir2,
                        "Coords ({}, {}) and ({}, {}) should produce different grid dirs",
                        lat1, lon1, lat2, lon2);
                }
            }
        }
    }
}
