//! TUI Application module for XEarthLayer CLI.
//!
//! This module contains the TUI (Terminal User Interface) application logic,
//! separated from the command-line argument parsing and service orchestration.
//!
//! # Architecture
//!
//! - `run_tui()` - Interactive TUI application with dashboard and event loop
//! - `run_headless()` - Simple headless mode for non-TTY environments
//! - `TuiAppConfig` - Configuration struct for TUI initialization
//!
//! The `run.rs` command acts as a thin front controller that:
//! 1. Loads and validates configuration
//! 2. Creates the `ServiceOrchestrator`
//! 3. Delegates to `run_tui()` or `run_headless()`

use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::time::{Duration, Instant};

use tokio_util::sync::CancellationToken;

use xearthlayer::aircraft_position::SharedAircraftPosition;
use xearthlayer::config::ConfigFile;
use xearthlayer::manager::{InstalledPackage, LocalPackageStore};
use xearthlayer::prefetch::{PrewarmProgress as LibPrewarmProgress, SharedPrefetchStatus};
use xearthlayer::service::{PrewarmOrchestrator, ServiceOrchestrator, StartupProgress};
use xearthlayer::xplane::XPlaneEnvironment;

use crate::error::CliError;
use crate::ui::{
    self, Dashboard, DashboardConfig, DashboardEvent, DashboardState, LoadingPhase,
    LoadingProgress, PrewarmProgress,
};

/// Configuration for starting the TUI application.
pub struct TuiAppConfig<'a> {
    /// Service orchestrator for all backend services.
    pub orchestrator: &'a mut ServiceOrchestrator,
    /// Local package store for package discovery.
    pub store: &'a LocalPackageStore,
    /// Shutdown signal from signal handler.
    pub shutdown: Arc<AtomicBool>,
    /// Configuration file.
    pub config: &'a ConfigFile,
    /// Prefetch status for UI display.
    pub prefetch_status: Arc<SharedPrefetchStatus>,
    /// Unified aircraft position provider (APT module).
    pub aircraft_position: SharedAircraftPosition,
    /// Ortho packages to mount.
    pub ortho_packages: Vec<&'a InstalledPackage>,
    /// Airport ICAO code for prewarm (if specified).
    pub airport_icao: Option<String>,
    /// X-Plane environment for apt.dat lookup and resource paths.
    pub xplane_env: Option<XPlaneEnvironment>,
}

/// Run the TUI application with dashboard.
///
/// This function:
/// 1. Starts the TUI immediately in Loading state
/// 2. Initializes all services via ServiceOrchestrator with progress updates
/// 3. When complete, optionally prewarm cache around airport
/// 4. Enters main event loop for Running state
///
/// Returns the cancellation token for cleanup coordination.
pub fn run_tui(config: TuiAppConfig) -> Result<CancellationToken, CliError> {
    let TuiAppConfig {
        orchestrator,
        store,
        shutdown,
        config: cfg,
        prefetch_status,
        aircraft_position,
        ortho_packages,
        airport_icao,
        xplane_env,
    } = config;

    let dashboard_config = DashboardConfig {
        memory_cache_max: cfg.cache.memory_size,
        disk_cache_max: cfg.cache.disk_size,
        provider_name: cfg.provider.provider_type.clone(),
    };

    // Create initial loading progress
    let loading_progress = LoadingProgress::new(ortho_packages.len());

    // Start dashboard in Loading state
    let initial_state = DashboardState::Loading(loading_progress);
    let mut dashboard = Dashboard::with_state(dashboard_config, shutdown.clone(), initial_state)
        .map_err(|e| CliError::Config(format!("Failed to create dashboard: {}", e)))?
        .with_prefetch_status(Arc::clone(&prefetch_status))
        .with_aircraft_position(aircraft_position.clone());

    // Draw initial loading screen immediately
    dashboard
        .draw_loading()
        .map_err(|e| CliError::Config(format!("Dashboard draw error: {}", e)))?;

    // Channel for progress updates from initialization
    let (progress_tx, progress_rx) = std::sync::mpsc::channel();

    // Run initialization in a scoped thread so we can update dashboard
    // Use a Mutex to store the result for thread-safe access
    let init_result: std::sync::Mutex<Option<Result<_, xearthlayer::service::ServiceError>>> =
        std::sync::Mutex::new(None);

    std::thread::scope(|s| {
        // Spawn initialization thread - borrows from outer scope (scoped threads allow this)
        let progress_tx_clone = progress_tx.clone();
        let init_result_ref = &init_result;
        s.spawn(|| {
            // Progress callback needs move to own progress_tx_clone
            let progress_callback = move |progress: StartupProgress| {
                let _ = progress_tx_clone.send(progress);
            };

            let result =
                orchestrator.initialize_services(store, &ortho_packages, Some(progress_callback));
            *init_result_ref.lock().unwrap() = Some(result);
        });

        // Update dashboard while initialization is in progress
        let tick_rate = Duration::from_millis(50);
        loop {
            // Process progress updates
            while let Ok(progress) = progress_rx.try_recv() {
                update_loading_progress(&mut dashboard, &progress);
            }

            // Check if initialization is complete
            if init_result.lock().unwrap().is_some() {
                break;
            }

            // Not ready yet - draw dashboard and wait
            if let Err(e) = dashboard.draw_loading() {
                tracing::warn!(error = %e, "Dashboard draw error during init");
            }
            std::thread::sleep(tick_rate);
        }
    });

    // Check initialization result
    let result = init_result
        .into_inner()
        .unwrap()
        .ok_or_else(|| CliError::Config("Initialization failed".to_string()))?;
    let _startup_result = result.map_err(CliError::Serve)?;

    // Wire in runtime health for TUI display
    if let Some(runtime_health) = orchestrator.runtime_health() {
        let max_concurrent_jobs = orchestrator.max_concurrent_jobs();
        dashboard = dashboard.with_runtime_health(runtime_health, max_concurrent_jobs);
    }

    // Transition to Running state
    dashboard.transition_to_running();

    // Get runtime handle for prewarm
    let runtime_handle = tokio::runtime::Handle::current();

    // Track prewarm state
    let mut prewarm_handle: Option<xearthlayer::service::PrewarmHandle> = None;
    let mut prewarm_active = false;
    let mut prewarm_complete = false;

    // Start prewarm if airport specified
    if let Some(ref icao) = airport_icao {
        let prewarm_config = orchestrator.config().prewarm.clone();
        match PrewarmOrchestrator::start(
            orchestrator,
            icao,
            xplane_env.as_ref(),
            &aircraft_position,
            &prewarm_config,
            &runtime_handle,
        ) {
            Ok(result) => {
                tracing::info!(
                    icao = %icao,
                    airport = %result.airport_name,
                    tiles = result.estimated_tiles,
                    "Starting prewarm in background"
                );
                prewarm_handle = Some(result.handle);
                prewarm_active = true;

                let prewarm_progress = PrewarmProgress::new(icao, result.estimated_tiles);
                dashboard.update_prewarm_progress(prewarm_progress);
            }
            Err(e) => {
                tracing::warn!("Prewarm skipped: {}", e);
                prewarm_complete = true;
            }
        }
    } else {
        prewarm_complete = true;
    }

    // Main event loop
    let tick_rate = Duration::from_millis(100);
    let mut last_tick = Instant::now();

    loop {
        // Poll for events
        match dashboard.poll_event() {
            Ok(Some(DashboardEvent::Quit)) => break,
            Ok(Some(DashboardEvent::Cancel)) => {
                // Cancel prewarm if active
                if prewarm_active && !prewarm_complete {
                    tracing::info!("Prewarm cancelled by user");
                    if let Some(ref handle) = prewarm_handle {
                        handle.cancel();
                    }
                    prewarm_complete = true;
                    prewarm_active = false;
                }
            }
            Ok(None) => {}
            Err(e) => return Err(CliError::Config(format!("Dashboard error: {}", e))),
        }

        // Handle prewarm progress updates
        if let Some(ref mut handle) = prewarm_handle {
            while let Ok(progress) = handle.try_recv_progress() {
                match progress {
                    LibPrewarmProgress::Starting { total_tiles } => {
                        if let Some(prewarm) = dashboard.prewarm_status().cloned() {
                            let mut updated = prewarm;
                            updated.total_tiles = total_tiles;
                            dashboard.update_prewarm_progress(updated);
                        }
                    }
                    LibPrewarmProgress::TileCompleted => {
                        if let Some(prewarm) = dashboard.prewarm_status().cloned() {
                            let mut updated = prewarm;
                            updated.tile_loaded(false);
                            dashboard.update_prewarm_progress(updated);
                        }
                    }
                    LibPrewarmProgress::TileCached => {
                        if let Some(prewarm) = dashboard.prewarm_status().cloned() {
                            let mut updated = prewarm;
                            updated.tile_loaded(true);
                            dashboard.update_prewarm_progress(updated);
                        }
                    }
                    LibPrewarmProgress::BatchProgress {
                        completed,
                        cached,
                        failed: _,
                    } => {
                        if let Some(prewarm) = dashboard.prewarm_status().cloned() {
                            let mut updated = prewarm;
                            updated.tiles_loaded_batch(completed, cached);
                            dashboard.update_prewarm_progress(updated);
                        }
                    }
                    LibPrewarmProgress::Complete {
                        tiles_completed,
                        cache_hits,
                        failed,
                    } => {
                        tracing::info!(tiles_completed, cache_hits, failed, "Prewarm complete");
                        prewarm_complete = true;
                        prewarm_active = false;
                        dashboard.clear_prewarm_status();
                    }
                    LibPrewarmProgress::Cancelled {
                        tiles_completed,
                        tiles_pending,
                    } => {
                        tracing::info!(tiles_completed, tiles_pending, "Prewarm cancelled");
                        prewarm_complete = true;
                        prewarm_active = false;
                        dashboard.clear_prewarm_status();
                    }
                }
            }
        }

        // Update dashboard at tick rate
        if last_tick.elapsed() >= tick_rate {
            let snapshot = orchestrator.telemetry_snapshot();
            dashboard
                .draw(&snapshot)
                .map_err(|e| CliError::Config(format!("Dashboard draw error: {}", e)))?;
            last_tick = Instant::now();
        }

        // Small sleep to prevent busy-waiting
        std::thread::sleep(Duration::from_millis(10));
    }

    Ok(orchestrator.cancellation())
}

/// Update dashboard loading progress based on StartupProgress.
fn update_loading_progress(dashboard: &mut Dashboard, progress: &StartupProgress) {
    match progress {
        StartupProgress::Mounting {
            phase,
            current_source,
            sources_complete,
            sources_total,
            files_scanned,
            using_cache,
        } => {
            let mut loading = LoadingProgress::new(*sources_total);
            loading.phase = match phase {
                xearthlayer::ortho_union::IndexBuildPhase::Discovering => LoadingPhase::Discovering,
                xearthlayer::ortho_union::IndexBuildPhase::CheckingCache => {
                    LoadingPhase::CheckingCache
                }
                xearthlayer::ortho_union::IndexBuildPhase::Scanning => LoadingPhase::Scanning,
                xearthlayer::ortho_union::IndexBuildPhase::Merging => LoadingPhase::Merging,
                xearthlayer::ortho_union::IndexBuildPhase::SavingCache => LoadingPhase::SavingCache,
                xearthlayer::ortho_union::IndexBuildPhase::Complete => LoadingPhase::Complete,
            };
            loading.current_package = current_source.clone().unwrap_or_default();
            loading.packages_scanned = *sources_complete;
            loading.tiles_indexed = *files_scanned;
            loading.using_cache = *using_cache;
            dashboard.update_loading_progress(loading);
        }
        StartupProgress::CreatingOverlay => {
            // Keep current progress, just log
            tracing::debug!("Creating overlay symlinks");
        }
        StartupProgress::StartingTelemetry => {
            tracing::debug!("Starting APT telemetry");
        }
        StartupProgress::BuildingSceneryIndex {
            package_name,
            package_index,
            total_packages,
            tiles_indexed,
            ..
        } => {
            let mut loading = LoadingProgress::new(*total_packages);
            loading.phase = LoadingPhase::Scanning;
            loading.current_package = format!("Indexing: {}", package_name);
            loading.packages_scanned = *package_index;
            loading.tiles_indexed = *tiles_indexed;
            dashboard.update_loading_progress(loading);
        }
        StartupProgress::SceneryIndexComplete {
            total_tiles,
            land_tiles,
            sea_tiles,
        } => {
            tracing::info!(
                total = total_tiles,
                land = land_tiles,
                sea = sea_tiles,
                "Scenery index complete"
            );
        }
        StartupProgress::StartingPrefetch => {
            tracing::debug!("Starting prefetch system");
        }
        StartupProgress::Complete => {
            tracing::info!("All services initialized");
        }
    }
}

/// Run in headless mode (non-TTY environments).
///
/// This is a simple wait loop that displays periodic telemetry stats
/// until the shutdown signal is received.
pub fn run_headless(
    orchestrator: &mut ServiceOrchestrator,
    shutdown: Arc<AtomicBool>,
) -> Result<(), CliError> {
    println!("Start X-Plane to use XEarthLayer scenery.");
    println!("Press Ctrl+C to stop.");
    println!();

    let mut last_telemetry = Instant::now();
    let telemetry_interval = Duration::from_secs(30);

    while !shutdown.load(Ordering::SeqCst) {
        std::thread::sleep(Duration::from_millis(100));

        // Display telemetry every 30 seconds
        if last_telemetry.elapsed() >= telemetry_interval {
            let snapshot = orchestrator.telemetry_snapshot();
            ui::dashboard::print_simple_status(&snapshot);
            last_telemetry = Instant::now();
        }
    }

    Ok(())
}
